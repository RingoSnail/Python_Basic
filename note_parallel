8.1 计算机硬件-操作系统-用户接口程序-应用程序
    空间复用：内存分为几部分，每部分放入一个程序
    时间复用：I/O时，进程之间分时切换

8.2 程序与进程
    并发与并行 多道与多核
    进程的状态：1.运行 2.阻塞 3.就绪
    线程数：主线程+子线程

8.8 生产者 <----> 队列 <----> 消费者
    利用队列进行解耦

8.9 进程相当于车间（整合资源），线程相当于其中的流水线（工作过程）
    同一个进程内的多个线程共享该进程内的地址资源
    创建线程的开销要远小于创建进程的开销

8.13 守护进程/线程
    主进程完毕-守护进程回收-非守护进程完毕-非守护进程回收（进程彼此隔离，主进程该结束就结束）
    非守护线程完毕-主线程完毕-守护线程回收            （线程彼此共享，主线程必须等所有一起结束）

8.14 GIL
    python-Cpython解释器-GIL特性（互斥锁，同一时刻只能一个线程执行，无法利用多核优势）
    进程内所有数据共享，包括代码、解释器代码

    使用多核计算机，python开启多线程：
    对于计算密集型任务，不能带来多大性能提升，甚至不如串行(没有大量切换)
    对于IO密集型的任务，有显著效率提升(切换快)。

    多线程用于IO密集型，如socket，爬虫，web
    多进程用于计算密集型，如金融分析

8.19 协程
    并发的本质：切换任务+保存状态
    协程：单线程实现并发，又称微线程，纤程。英文名Coroutine。
    一句话说明什么是线程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。

 8.22 IO模型
    阻塞IO 非阻塞IO 同步IO 异步IO

    网络编程：
    1.阻塞IO
    1)socket接口大多是阻塞型
    2)使用多线程，但大量连接时，严重占用资源、影响效率
    3)使用线程池，减少创建销毁线程的频率，维持合理数量的线程
      ”池“必须根据请求规模调整大小

    2.非阻塞IO
    1)内核对系统调用立刻返回error，直至数据准备完成
    2)反复进行系统调用，称为”轮询“，期间可以做其他事
    3)拷贝数据，为阻塞态
    优点：等待IO完成时间内可以执行其他任务
    缺点：轮询占用CPU，响应延迟增大，整体吞吐量降低

    3.事件IO (event driven IO) (IO multiplexing)
    1)由select轮询其负责的所有socket，任何一个socket的数据准备好了就返回，进入拷贝状态
    2)select会循环遍历它所监测的fd_set内的 所有文件描述符对应的驱动程序的poll函数，
    驱动程序提供的poll函数首先会将调用select的用户进程插入到该设备驱动对应资源的等待队列(如读/写等待队列)，
    然后返回一个bitmask告诉select当前资源哪些可用
    3)select优势在于可以处理多个连接，不适用于单个连接，只用单线程执行，占用资源少
    4)select缺点在于不如epoll高效

8.27 IO模型比较
    阻塞/非阻塞
    同步/异步
    在non-blocking IO中，虽然进程大部分时间都不会被block，
    但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。

    而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人(kernel)完成，然后他人做完后发信号通知，
    在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

8.28 IO复用
    服务端调用select和poll复用进程，为客户端IO进行服务
    select，poll，epoll本质是同步IO，因为需要自己进行读写，此读写过程是阻塞的，而异步IO无需自己负责进行读写